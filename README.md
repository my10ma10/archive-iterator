# Задача: Итераторы для композитного «архива» (дерево файлов)
Смоделирвать древовидный архив:
- Node (абстрактный): name(), виртуальный дестр.
- File (лист): size().
- Dir (составной): хранит ```cpp std::vector<std::unique_ptr<Node>> children ```

## Цель
Сделать набор внешних итераторов (STL-совместимых), которые позволяют обходить структуру не раскрывая внутреннее представление.

## Этап 1 — Базовый DFS итератор
- Реализовать прямой (pre-order) DFS итератор по Node: ```Archive::dfs()``` возвращает обёртку-диапазон с ```begin()/end()```.
- Минимальная категория — ```std::forward_iterator_tag```.
- Внутри без рекурсии (используй стек): доппамять O(глубина).
- Итератор должен работать в ```for (auto& node : archive.dfs())```.
- Должен поддерживать const-вариант (итерация по ```const Node```).

Проверка (ожидаемый порядок) на дереве:
```css
root
 ├─ a.txt(2)
 ├─ docs/
 │   ├─ readme.md(5)
 │   └─ img/
 │       └─ logo.png(7)
 └─ bin/
     └─ app(3)
```

DFS pre-order:
root, a.txt, docs, readme.md, img, logo.png, bin, app.

## Этап 2 — «Только файлы» (flatten)
Сделать диапазон ```archive.files()``` → итератор пропускает директории и даёт только File.

Должен работать с алгоритмами STL:

```cpp std::accumulate(archive.files().begin(), archive.files().end(), 0ULL, [](auto s, const File& f){ return s + f.size(); });```

Ожидаемый порядок файлов: a.txt, readme.md, logo.png, app.

## Этап 3 — BFS итератор
archive.bfs() — обход в ширину, очередь O(ширина уровня).

Порядок для дерева выше:
root, a.txt, docs, bin, readme.md, img, app, logo.png.

## Этап 4 — Фильтрация и совместимость с ranges

Вариант А: свой FilterIterator с предикатом (например, «файлы > N байт»).

Вариант B (предпочтительно): сделай, чтобы твои диапазоны дружили с std::ranges, т.е. можно писать:

for (const File& f : archive.files() | std::views::filter([](const File& f){ return f.size() > 4; })) { ... }


Для этого диапазоны должны возвращать корректные begin/end и соответствовать требованиям range.

## Этап 5 — Политика инвалидирования и fail-fast

Документируй: какие операции инвалидируют какие итераторы (добавление/удаление детей в любом узле).

Реализуй версионирование (напр., std::size_t mod_count в Dir и в корне) и проверяй в отладочных сборках: при operator++/operator* если модифицирован архив — кидай исключение (или assert).

## Этап 6 — Константность и категории

Поддержи const_iterator и iterator.

Гарантируй не менее ForwardIterator. Объясни, почему не делаешь Bidirectional для DFS/BFS (или сделай двунаправленный DFS с хранением «следа» — это усложнение).

## Этап 7 — API и удобства

У корня: Archive archive{Dir("root")};

Фабричный метод у Dir: addFile(name, size), addDir(name) возвращает ссылку на добавленную директорию (чтобы строить цепочки).

Запрети копирование Node; перемещение разреши. Node с виртуальным деструктором.

Обязательно без утечек (всё на unique_ptr).

## Критерии приёмки

Все три обхода (DFS, Files-only, BFS) выдают ровно описанные последовательности на эталонном дереве.

Работает с std::accumulate, std::count_if, std::ranges::find_if.

Константная итерация не даёт менять Node/File.

Документация по инвалидированию + проверка fail-fast в debug.

Отсутствуют рекурсии в итераторах (итеративные структуры данных).

Сложность: один проход O(N); доппамять — как оговорено.

Доп. задания (по желанию)

Order strategy: параметризированный итератор: dfs<Order::Pre> / dfs<Order::Post>.

Зип-итератор: по двум files() параллельно, выдаёт пары по имени (merge-like).

Top-K: используя files() и std::partial_sort/std::nth_element — выведи топ-3 самых больших файлов.

Коррутины (C++20): генератор co_yield для DFS вместо ручного стека.

Кэширование размеров директорий и инвалидация кэша при модификации.

## Частые грабли (подсказки)

Не лезь во внутренние children извне — вся навигация только через итераторы и публичные методы.

Не смешивай владение: дерево владеет Node через unique_ptr; итераторы хранят сырые указатели/итераторы контейнера, но не владеют.

При resize/insert во внутренних векторах итераторы инвалидируются — поэтому изменения структуры во время обхода запрещены (и ловятся версионированием).